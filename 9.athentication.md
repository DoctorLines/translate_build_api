# 9. Аутентификация

---

## 9.1 Введение
Реализация идентификации в API может быть одной из самых сложных задач для многих разработчиков, частично из-за того, что существует несколько различных способов, но в основном потому, что ни один из них не похож на обычную авторизацию в "web приложении". Когда создается адммин-панель, CMS, блог, и т.д., обычно принято использовать стандартный способ авторизации с использованием сессии, которая хранит данные как куки, в Memcache, Redis, Mongo, или в какой-нибудь SQL платформе. Несмотря на способ хранения данных, сессии используются потому, что однажды авторизовавшись, браузер запоминает кто пользователь. Для входа в систему пользователю предоставляется HTML форма, содержащая 2 поля: Одно из них Username и/или E-mail, а другое - пароль. После того, как конечный пользователь закрывает браузер, или отсутствует определенный период времени, тогда данные авторизации забываются браузером. Это стандартный способ реализации авторизации для подавляющего большинства сайтов, написанных на серверных языках, но это все совсем не похоже на то, как реализуется авторизация для API. В этой главе мы рассмотрим самые распространенные методы авторизации для API и рассмотрим плюсы и минусы каждого из них.

---

## 9.2 Когда нужна авторизация?
Авторизация позволяет API отслеживать пользователей, предоставлять им только определенные действия (типа "найти все мои сообщения"), лимитировать доступ пользователей к различным функциям, фильтрации данных или даже деактивации аккаунтов. Это все очень полезно для многих API, но для некоторых действий авторизация вовсе не требуется.

### API только для чтения (read-only)
Если ваш API полностью предназначен только для чтения (read-only), и передача данных не предполагается, тогда вы можете просто сделать его доступным без авторизации, и не беспокоиться об этом. Это вполне нормально.

Стоит позаботиться о том, что некоторые личности могут использовать против вашего API DDoS атаки (со злым умыслом засыпать API бесчисленным множеством запросов), но использование какой-нибудь формы авторизации может ограничить количество векторов атак. Для получения ответа от API пользователь должен быть валидным, а следовательно, если вредоносная активность была обнаружена, аккаунт пользователя должен быть заблокирован или деактивирован.

Такие меры не избавят полностью от DDoS атак, но зато API будет выполнять меньше работы, т.к. запрос будет завершен гораздо раньше, если пользователь будет определен как блокированный (invalid). Так что, если проблемы с DDoS атаками остаются (не зависимо от того, есть авторизация в API или нет), тогда решением может быть использование самосовершенствующегося фаервола или реализация других барьеров безопасности. Вообще говоря, будет не очень хорошо, если ваши сервера будет кто-нибудь спамить, по этому может стоит заранее перейти на проверку подлинности, чтобы избежать таких атак.

В любом случае вы можете сначала сделать свой API без авторизации, а затем по частям её реализовывать в дальнейшем.

### Внутреннее API
Если ваше API работает внутри приватной сети, или блокируется правилами фаервола, и вам не требуется наличие конкретных пользовательских данных, тогда, вероятно, авторизацию можно и не делать совсем.

Одна из проблем, которая касается безопасности всех сетей, это если сеть будет "пробита", тогда хакеры могут нанести много вреда, т.к. если они имеют доступ ко всем вашим сетям, то вероятно осталось еще много нерешенных вопросов безопасности.

Помните об этом.

---

## 9.3 Различные способы авторизации
### Способ №1: Basic Authentication
Первый способ, которым пользуется множество разработчиков, это HTTP Basic авторизация, который больше всего напоминает стандартный username/password подход, давно известный и полюбившийся, реализованный на уровне HTTP запроса и легко поддерживается браузерами.

Вот что в Wikipedia написано про него:

> HTTP Basic authentication (BA) реализует технически простой контроль доступа к web ресурсу, потому что не требует cookie, идентификатор сессии и страниц с формой авторизации. Зато, HTTP Basic авторизация использует статические, стандартные HTTP заголовки, что обеспечивает идентификацию без задержки.
> **Источник**: [Wikipedia](http://en.wikipedia.org/wiki/Basic_access_authentication)

**Плюсы**
- Простота в использовании
- Простота в понимании
- Работает в браузере и любых других HTTP клиентах

**Минусы**
- Очень не безопасно при использовании HTTP
- Довольно не безопасно при использовании HTTPS
- Пароли могут быть сохранены браузером, что является отличной приманкой для пользователей, только и ждущих заглотить эту наживку.

#### Сохранение паролей браузером

В браузере Chrome эти plain-text пароли даже не защищены мастер-ключем, вы реально оставляете ваших пользователей в открытом доступе для кражи, если вы используете HTTP Basic авторизацию.

Эллиот Кембер публично [описал эту проблему](http://blog.elliottkember.com/chromes-insane-password-security-strategy).
[The Guardian](http://www.theguardian.com/technology/2013/aug/07/google-chrome-password-security-flaw?INTCMP=SRCH).
[Sir Tim Berners-Lee](https://twitter.com/timberners_lee/status/364839351651274752).
[А Google воздержался от комментариев](https://news.ycombinator.com/item?id=6166886).

#### Другие проблемы plane-text

Другая проблема безопасности Basic авторизации - это чертовски небезопасная работа через HTTP.

Например, заголовок, предоставляемый Wikipedia, будет размещен в HTTP запросе примерно вот так:
`Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==`

Если запрос ушел по проводам (например JS-based API запрос от пользователя, который сидел в кафе), тогда этот запрос мог быть очень просто перехвачен. Получив такой заголовок, как в примере, безумно просто получить username и password.

``` 
1 $ php -a
2 php > echo base64_decode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==');
3 Aladdin:open sesame
```

Это не более и не менее безопасно, чем HTML форма входа, но это конечно не достаточно безопасно для любого API, принимающего данные. 

Использование SSL в значительной степени повышает безопасность, но так как пароль высылается в каждом HTTP запросе, то это остается потенциальной возможностью для его подбора - но это уже для тех, кто действительно хочет его получить.

HTTP Basic авторизация может действительно хорошо подойти для малозначимых, внутренних API, которые нуждаются только в базовой защите и должны быть реализованы быстро, но конечно совершенно не годится для всего, что связанно с деньгами, воздушным трафиком и ядерным оружием.

### Способ №2: Цифровая авторизация
Цифровой способ похож на Basic авторизацию, но разработан с упором на большую безопасность.

Вместо отправки паролей в виде plain-text, тут создается и отправляется MD5 хеш. По сравнению с Base64-based паролями, используемыми в Basic авторизации, MD5 является односторонним хешем, то есть вы не можете просто так взять хеш и рассчитать оригинальный пароль, не пробуя много различных комбинаций.

`HA1 = MD5(A1) = MD5(username:realm:password) HA2 = MD5(A2) = MD5(method:digestURI) response = MD5(HA1:nonce:HA2)`

nonce - это уникальный номер, который может содержать (но не обязательно), timestamp. Это может предотвратить повторные атаки, т.к. хеш уже не будет использоваться после этого времени.

**Плюсы**
- Пароль не передается как plane-text
- Использование nonce помогает избежать атаки [rainbow table](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B4%D1%83%D0%B6%D0%BD%D0%B0%D1%8F_%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0)
- Вообще говоря, более безопасна, чем Basic авторизация
- Проще в реализации, чем некоторые другие решения

**Минусы**
- Реализовать хорошо труднее, чем Basic авторизацию
- Просто реализовать плохо
- Остается незащищенной через HTTP
- Как и в Basic авторизации, пароли могут быть сохранены в браузере.
- Использует MD5conflated

#### MD5... 4... 3... 2... 1... Хакнуто
Сегодня MD5 воспринимается многими людьми как чрезвычайно подверженный взлому в большинстве сценариев. Цифровая авторизация так и не была улучшена с момента её создания в 1993 году, и хотя процесс расчета должен был предотвратить многие из этих проблем, плохая реализация цифровой авторизации открывает некоторые незаметные векторы атак, о которых вы узнаете только после их свершения.

Конечно, цифровая авторизация более безопасна, чем Basic. Она хороша в связке с SSL, безусловно, это хороший выбор для внутреннего API, если у вас конечно есть достаточно времени для ее реализации, но требование пересылать постоянно username и password говорит о потенциальной уязвимости, если у хакера будет достаточно зашифрованных реквестов, доступных для обработки.

### Способ №3: OAuth 1.0a
Сейчас не сильно популярен, но OAuth 1.0a является большим игроком на сцене  web-based авторизации, используемый такими сервисами как Dropbox, Flickr, Twitter, Google, LinkedIn и Tumblr. С тех пор большинство из них перешло на OAuth 2, который будет рассматриваться позже. Это две очень различные вещи, и их не следует совмещать.

> OAuth предоставляет клиенту метод для доступа к ресурсам сервиса от имени владельца ресурса (например различных клиентов или конечных пользователей). Он так же предоставляет для конечных пользователей процесс авторизации для доступа третьим лицам без предоставления авторизационных данных (обычно пара логин и пароль), с помощью User-Agent перенаправления.
> **Источник**: [Wikipedia](https://en.wikipedia.org/wiki/OAuth)

До этого мы рассматривали технологии авторизации, которые по существу были "встроены в браузер", и не достаточно гибкие в своем использовании. OAuth 1.0 была хорошим решением в сервисах социальных сетей, для реализации web-based HTML формы авторизации, которая выглядит так же как и любая другая форма авторизации (обычно брендированная логотипом, цветовыми схемами и т.д.), и могла бы затем отправить тебя обратно на сторонний web-сайт, для всех удивительных видов интеграции.

Например, когда Twitter перешел с HTTP Basic авторизации на OAuth 1.0, это означало, что вместо того, чтобы третие лица (iPhone приложений, других web-сайтов, CMS, чего угодно) спрашивали у конечных пользователей логин и пароль (которые должны были быть сохранены где-нибудь в plain-text), третья сторона перенаправляла пользователя на web-сайт Twitter, заставляла его войти, вернуться обратно на сервис и сохранить специальный токен, вместо сохранения пароля. OAuth 1.0a называет эти токены "OAuth Token" и "OAuth Token Secret".

OAuth 1.0a очень безопасна, даже если работает не через SSL. Это означало, что были невероятные сложности, связанные с установкой сигнатур (которые готовили по различным алгоритмам, включая HMAC-SHA1 и RSA-SHA1 или даже plain-text). Это добавило больших сложностей в написание клиентского кода, так как вы должны убедиться, что вы поддерживаете правильную сигнатуру, а большинство реализаций PHP (включая и мою собственную старую CodeIgniter Spark) не поддерживает их все.

Обычно, HTTP запрос, подписанный OAuth 1.0a, будет выглядеть примерно следующим образом:
``` 
 1 POST /moments/1/gift HTTP/1.1
 2 Host: api.example.com
 3 Authorization: OAuth realm="http://sp.example.com/",
 4 oauth_consumer_key="0685bd9184jfhq22",
 5 oauth_token="ad180jjd733klru7",
 6 oauth_signature_method="HMAC-SHA1",
 7 oauth_signature="wOJIO9A2W5mFwDgiDvZbTSMK%2FPY%3D",
 8 oauth_timestamp="137131200",
 9 oauth_nonce="4572616e48616d6d65724c61686176",
10 oauth_version="1.0"
11 Content-Type: application/json
12 
13 { "user_id" : 2 } 
```

Обалдеть.

Другие осложнения были из-за различных реализаций. Двуногие (правильные и не правильные) и трехногие. Это все невероятно запутано, так что я позволю Mashape объяснить: [OAuth Bible: OAuth Flows](https://github.com/Mashape/mashape-oauth/blob/master/FLOWS.md#oauth-10a-one-legged).

Был так же и xAuth, который оставался OAuth 1.a, но разработанный для мобильных и десктопных приложений, которые не имели простого доступа к браузеру. Для web-приложения гораздо проще вывести popup-окно ява-скриптом, или перенаправить пользователя, чем это сделать в мобильном приложении, и для него более просто получить OAuth Token чем в других реализациях. 

И наконец, даже если вы получили OAuth Token и Secret, вам нужно разместить OAuth Token в заголовке запроса, и использовать Secret для подписи сигнатуры, которая должна зашифровать запрос - делая все это хорошо и безопасно. А если к этому всему еще добавить SSL, то вы получаете очень хоро защищенную конструкцию... разве что токены могут оставаться некоторое время после создания, и со временем их безопасность может быть нарушена. Кто-то может восстановить данные с ноутбука, который вы продали на eBay, или потенциальный хакер может перехватить достаточное количество пакетов трафика, подписанного вашей сигнатурой и в конечном счете программно угадать токен и секрет.


**Плюсы**
- Супер защита, даже без SSL
- Не отправляет логин и пароль в каждом запросе - как plaintext или хеш
- Останавливает приложения третьей стороны, ищущие или сохраняющие ваш логин или пароль
- Если атакующий получает OAuth Token и даже Secret, он все равно не сможет изменить ваш пароль, то есть вы защищены от "угона" аккаунта

**Минусы**
- Довольно сложное взаимодействие, даже если у вас хорошо спроектированная клиентская библиотека. Для PHP никогда не было такой, но [Лига экстраординарных пакетов](http://thephpleague.com/) недавно [сделала один](https://github.com/thephpleague/oauth1-client)
- Ограниченное количество способов получения прав доступа. xAuth и Двух/трех-ногие потоки завершаются обычно жестко.
- Токен ни когда не меняется, так что безопасность, по существу, зависит от того, как долго и как часто вы пользуетесь сервисом.

OAuth 1.0a  была бы хорошей технологией для реализации, если бы вы создавали web-сайт с публичным user-based API... и если бы вы создавали его в году 2009-2010. Но сейчас, вероятно, нет.

### Способ №4: OAuth 2.0
В OAuth 2 "secret token" больше не используется, теперь пользователям достаточно получить "Access Token", так же не требуется генерация сигнатуры. Это может показаться большим шагом назад в безопасности, но на самом деле это был довольно мудрый шаг. В спецификации OAuth 1.0a SSL является опциональным, а в OAuth 2.0 он обязателен. Перенос шифрования запроса на SSL выглядит очень логичным, и резко улучшает реализацию.

Даже обычный GET запрос в OAuth 1.0a выглядел ужасающе, т.к. вам всегда нужно устанавливать ваших потребителей, сигнатуры, и т.д., но c OAuth 2.0 вы можете просто сделать следующее:

```
1 file_get_contents('https://graph.facebook.com/me?access_token=DFGJKHDFGHDIFHGFKDJGHIU');
```

Или же, как мы говорили ранее в Главе 3, вы можете просто передать Access Token на сервер как HTTP Request заголовок:

```
1 POST /moments/1/gift HTTP/1.1
2 Host: api.example.com
3 Authorization: Bearer vr5HmMkzlxKE70W1y4MibiJUusZwZC25NOVBEx3BD1
4 Content-Type: application/json
5 
6 { "user_id" : 2 }
```

Это выглядит немного проще, чем работа с OAuth 1.0a, правда же?

<table>
    <tr><th colspan="2">Заголовок или URL</th></tr>
    <tr>
        <td width="128"><img src="/images/warning.png" align="left" width="128" /></td>
        <td>Вы можете всегда использовать заголовок Authorization для отправки токенов, ели хотите. Если использовать строку запроса (URL), то она защищена, когда используется SSL, но если запрос умышленно заблокировать, то access token будет светиться в логах сервера, и возможно в любых других местах. К тому же браузеры могут сохранять полные URL адреса (включая строку запроса) в истории, так можно легко нарушить целостность безопасности, если компьютер был украден, или если брат решит разыграть. </td>
    </tr>
</table>

#### Кратковременные токены (Short-life Tokens)
Как уже говорилось, OAuth 1.0a тоже всегда использует токены. У токенов доступа OAuth 2.0 срок действия истекает через произвольный период времени, указанный на OAuth сервере. При запросе токена доступа вы обычно получаете "Refresh Token" и продолжительность действия в секундах, после которых токен является не действительным. Некоторые сервера отправляют вам время истечения действия токена в формате unixtime. Люди реализуют получение этой информации разными способами по определенным причинам, но если вы знаете, какой будет лучше для вас, то это хорошо.

При использовании времени действия токена вы всегда будете знать, до каких пор он будет являться валидным, и так вы можете создать задачу для cron, которая будет активно обновлять токены доступа, или вы можете обернуть ваш HTTP запрос в обработчик исключения "Not Authorized" и обновить им токен, как это рекомендует спецификация OAuth 2.0.

Эта дополнительная возможность "Когда токен доступа истек, вы можете обновить его" изначально кажется запутанной и раздражающей, особенно, если вы привыкли "что однажды я получил токен, и он работает всегда", но это намного более безопасно. OAuth 1.0a, по существу, просто перестает принимать одну пару username и password и дает вам другую пару username и password (имеется ввиду token и secret) которые работают для одного определенного клиента. Некоторые хорошие сетевые администраторы могут сказать вам, что нужно регулярно менять свой пароль (не реже, чем раз в месяц), и OAuth не исключение, чем больше вы используете тот же пароль / токен, тем больше ваши шансы выяснить, почему это не безопасно.

#### Виды прав доступа (grant types)
Еще одна значительная особенность OAuth 2.0 по сравнению с OAuth 1.0a, это возможность иметь несколько (даже кастомных) прав доступа. Права доступа - это по существу "режим", в котором будет запущен OAuth 2.0 сервер, ожидая различные вводные, и возможно, предоставляя различные исходящие данные. Такая гибкость позволит вам создавать невероятные реализации разграничения прав доступа.

Наиболее распространенным видом прав доступа в OAuth 2.0 является принадлежность пользователя к authorization_code, что очень похоже на OAuth 1.0a. 

Клиентское web-приложение создает линк на OAuth сервер сервиса, на который пользователь хочет залогиниться (например Facebook), и логинит его. Facebook перенаправляет пользователя обратно на клиентское web-приложение через "Callback URL", c переменной `code=FOO` в строке запроса. Далее, web-приложение получает код, и создает второй запрос (Обычно POST запрос, но бывает и GET, в зависимости от популярности используемого API) на Facebook, и далее Facebook в ответ предоставляет токен доступа. Некоторые другие популярные API, например Google Apps - так же предоставляют expires и refresh токены.

Это только одно из решений, но их еще много. В связи со своей гибкостью, OAuth 2.0 хорошо подходит для большого количества сценариев авторизации в API, будь это обычный логин и пароль на одностраничном JavaScript приложении, задача cron, у которого нет доступа к базе данных или полномасштабное перенаправление пользователей между различными сайтами, гибкость кастомных видов прав доступа позволяет реализовать все что угодно.

Более подробно про это будет описано ниже, в секции "Права доступа в OAuth 2.0"

**Эрин Хаммер**

Часто меня спрашивают, почему кто-то до сих пор использует OAuth 2.0, после того как Эрин Хаммер (ведущий автор и редактор стандарта OAuth 2.0) [вычеркнул свое имя из его спецификации](http://hueniverse.com/2012/07/26/oauth-2-0-and-the-road-to-hell/). Это конечно спровоцировало множество волнений в интернете, но я лично искренне не согласен с его разногласиями. 

1. OAuth 2.0 менее безопасен, если вы не используете SSL/TSL. Правильно. Ну так используйте их.
2. Люди внедрили OAuth 2.0 плохо (если посмотреть на Facebook/Google/И большинство других провайдеров), но при хорошей реализации, это выглядит прекрасно. Используйте встроенные стандарты совместимой реализации, например [как такой для PHP](https://github.com/thephpleague/oauth2-server/).
3. Он считает, что обновление токенов (Refresh Tokens) раздражает, но я думаю, что обновлять токены хорошее решение.

Вобще говоря, его уход из проекта не такая уж и большая потеря. Я уверен, что [IETF](https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D0%B6%D0%B5%D0%BD%D0%B5%D1%80%D0%BD%D1%8B%D0%B9_%D1%81%D0%BE%D0%B2%D0%B5%D1%82_%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%BD%D0%B5%D1%82%D0%B0) заниматься распространением велосипедов не будут, но после нескольких лет использования OAuth 2.0 я стал гораздо счастливее, и действительно желаю чтобы [Twitter полностью проапгрейдился на него](https://dev.twitter.com/discussions/397), что бы мне ни когда не пришлось снова использовать OAuth 1.0a.

Вобще говоря OAuth 2.0 хорошо подходит для большинства ситуаций, при условии, что вы используете SSL, и используете хорошо протестированное решение для вашего OAuth 2.0 сервера. Попытка сделать это самостоятельно может быть невероятно трудной, и вполне может привести к тому что вы получите супер-взлом.

#### Другие походы:
* OpenID - [https://openid.net/](https://openid.net/)
* Hawk - [https://github.com/hueniverse/hawk](https://github.com/hueniverse/hawk)
* Oz - [https://github.com/hueniverse/oz](https://github.com/hueniverse/oz)

---

## 9.4 Реализация OAuth 2.0 сервера (OAuth 2.0 Server)
Обслуживание OAuth 2.0 сервера (или даже какого-то из его методов авторизации) может быть очень трудным. Эта глава нацелена на то, чтобы объяснить все плюсы и минусы, а так же примеры использования и реализацию, но к сожалению она очень объемна. Существует несколько реализаций, которые вы можете использовать.

### Реализация на PHP
Одна из реализаций стоит выше остальных в PHP-мире, и не потому что она написана моим другом: Алексом Билби ([Alex Bilbie](http://alexbilbie.com/)). Наша дружба началась не только потому, что он всесторонне хороший парень, но также и потому, что он религиозно изучил обе спецификации OAuth, и написал для них несколько замечательных тулз, которыми я сам пользовался много раз.

На своей последней работе в Университете Линкольна, он использовал OAuth для всего что только можно. Затем он получил финансирование для исследовательского проекта на создание замечательного open-source кода, который улучшит аутентификацию и совместимость. В результате, этот проект вылился в несколько больших пакетов, включая [PHP OAuth 2.0 Server](https://github.com/thephpleague/oauth2-server), который сейчас находится на главной странице [Лиги выдающихся пакетов (The League of Extraordinary Packages.)](http://thephpleague.com/). Это единственный PHP пакет, который реализует спецификацию OAuth 2.0 в полной мере, по этому его очень стоит попробовать.

> **OAuthello**
> 
> Алекс пишет [книгу](http://leanpub.com/oauthello-a-book-about-oauth/c/apisyouwonthate), охватывающую реализацию этого сервера в мельчайших подробностях и затрагивает все особенности OAuth.

Существует еще одна реализация PHP 2.0 OAuth сервера, которая вероятно, тоже работает.

### Реализация на Python

Есть две реализации для Python, который выглядят довольно неплохо. Одна из них [oauth2lib](https://github.com/NateFerrero/oauth2lib), которая по является форком проекта [pyoauth2](https://github.com/StartTheShift/pyoauth2). Авторы оригинального пакеты его забросили, по этому новый пришлось как-то переименовать.

Другая реализация, это [python-oauth2](https://github.com/simplegeo/python-oauth2), которая была разработана **SimpleGeo**. Они являлись крупным сервисом SaaS для гео позиционирования, но с тех пор были выкуплены и закрыты, а последнее упоминание о них было больше двух лет назад.

### Реализация на Ruby

Единственный активный и документированный Ruby OAuth 2.0 Server, который я смог найти, это Rack модуль под названием [Rack::OAuth2::Server](https://github.com/assaf/rack-oauth2-server). Он очень хорошо документирован с примерами реализации на Rails, Sinatra и Padrino.

---

## 9.5 Где живет OAuth 2.0 Server?

Многие предполагают, что OAuth 2.0 Server должен быть частью API сервиса. Даже если это несмоненно будет так, всеже так делать определенно не нужно.

OAuth сервер уже имеет веб интерфейс, который имеет HTML формы, валидаторы форм, и все виды статики (картинки, CSS, JavaScript, и т.д.). Это делает его более похожим на обычный web-сайт, так что если ваш API и web-сайт - разные сервисы, то сервер OAuth будет более правильно разместить рядом с сайтом.

Но в общем то говоря, лучше такие вещи держать как автономные сервисы. Вот например, если бы вы решили построить новую версию своего сайта на AngularJS вместо использования серверного кода, тогда предется поменять реализацию OAuth сервера тоже.

Вот если у вас OAuth сервер работает как отдельный сервис, или по крайне мере имеет свою собственную кодовую базу, тогда у вас не будет описанной выше проблемы.

Единственное, что нужно сделать вашему API, так это посмотреть на токен доступа (переданного в заголовке или в параметре запроса), затем опросить какое-нибудь хранилище (База данных SQL, MongoDB, и т.д.), которое содержит токены доступа. Проверить, что токен валидный (находится в БД и не просрочен), затем определить некоторого пользователя, привязанного к нему, и вытащить запись этого пользователя для дальнейшего использования в коде API.

Все перечисленное не является чем-то сложным, так что связывание сервиса API и сервера OAuth вместе в одном приложении с единой кодовой базой, выглядит довольно неуместно и без понимания предназначения каждого из них.

---

## 9.6 OAuth 2.0 Grant Types

В спецификации рассмотрены четыре гранта доступа:

### Код авторизации (Authorization Code)

Код авторизации это завершенный пользовательский поток (user-flow) с переадресацией.

Этот вариант особенно полезен, если у вас есть несколько сайтов (например сеть сайтов для игр, фильмов, книг, и т.д.) или вы просто хотите поделиться логинами с другими партнерами. Так же этот тип гранта, который вы скорее всего использовали для входа пользователей на Facebook или Google.

[Section 4.1 в спецификации](http://tools.ietf.org/html/rfc6749#section-4.1)

### Refresh Token

Refresh Token поддерживает большинство популярных провайдеров OAuth 2.0. Сначала, вы замечаете, что ваш старый access token больше не работает, и получаете в ответ статусный код HTTP 401 Unauthorized, но можно заказать новый access token, используя ваш refresh token. OAuth 2.0 сервер либо выдаст вам новый access token, либо откажет в выдаче. На этом этапе вам придется отправить своему пользователю email c сообщением: "Ваша учетная запись больше не подключена к Example.com, пожалуйста, нажмите здесь, чтобы подключить заново." Это не является распространенным явлением, и как правило, означает, что пользователь отключил доступ к этой учетной записи, так что ручной запрос в данном случае, буквально, единственный вариант.

Выглядит довольно запутанно, но на самом деле все достаточно просто и имеет ряд преимуществ.

По существу же, если использовать всегда один и тот же Access Token снова и снова, то есть большой шанс, что его кто-нибудь найдет. Существует множество причин, почему это может случиться: На сейте не реализован SSL, или сайт взломали, или системные администраторы случайно "засветили" логи доступа, или скорее всего, Access Token сохранился в браузере.

Хранение токена доступа в браузере не будет опасным, если срок действия этого токена заканчивается в ближайшее время, так как это означает, что у хакера есть очень небольшое "окно" во времени, чтобы успеть сделать что-либо, если конечно он найдет этот токен. Допустим хакер получил текущий токен доступа, но если его время действия всего 5 минут, то в следующий раз получить этот токен будет куда сложнее, и вероятно, хакеру потребуется физический доступ к устройству, которое использовалось, либо подключение по ssh - но в таком случае у вас проблемы гораздо значительнее.

Не все API будут проверять срок действия токена доступа, иногда ими можно пользоваться постоянно. Обычно такие токены могут использоваться вечно, либо они дают вам некоторое время и ожидают, что вы обновите их. Исключением в данном случае является Facebook, которые ничего не делают. Их подход заключается в том, что вынуждают вас отправить пользователя назад на facebook.com для входа в систему.

Расстраивает тот факт, что Facebook в очередной раз решили вопиюще пренебречь спецификацией OAuth 2.0, чтобы удовлетворить свои собственные потребности, нарушая стандартный user-flow и сбивая с толку разработчиков. Работая с подобными популярными API вы заметите множество похожих странностей, но эти различия гораздо менее проблематичны, чем если бы не было никакой спецификации OAuth 2.0 в их основе. По крайней мере, у таких API есть некий общий язык.

[Section 6 в спецификации](http://tools.ietf.org/html/rfc6749#section-6)

осталось перевести:

### Client Credentials

[Section 2.3.1 в спецификации](http://tools.ietf.org/html/rfc6749#section-2.3.1)

### Password (user credentials)

[Section 4.3 в спецификации](http://tools.ietf.org/html/rfc6749#section-4.3)

### Custom Grant Types