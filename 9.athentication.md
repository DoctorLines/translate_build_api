# 9. Идентификация
## 9.1 Введение

Реализация идентификации в API может быть одной из самых сложных задач для многих разработчиков, частично из-за того, что существует несколько различных способов, но в основном потому, что ни один из них не похож на обычную авторизацию в "web приложении". Когда создается адммин-панель, CMS, блог, и т.д., обычно принято использовать стандартный способ авторизации с использованием сессии, которая хранит данные как куки, в Memcache, Redis, Mongo, или в какой-нибудь SQL платформе. Несмотря на способ хранения данных, сессии используются потому, что однажды авторизовавшись, браузер запоминает кто пользователь. Для входа в систему пользователю предоставляется HTML форма, содержащая 2 поля: Одно из них Username и/или E-mail, а другое - пароль. После того, как конечный пользователь закрывает браузер, или отсутствует определенный период времени, тогда данные авторизации забываются браузером. Это стандартный способ реализации авторизации для подавляющего большинства сайтов, написанных на серверных языках, но это все совсем не похоже на то, как реализуется авторизация для API. В этой главе мы рассмотрим самые распространенные методы авторизации для API и рассмотрим плюсы и минусы каждого из них.

## 9.2 Когда нужна авторизация?

Авторизация позволяет API возможность отслеживания пользователей, предоставлять им только определенные действия (типа "найти все мои сообщения"), лимитировать доступ пользователей к различным функциям, фильтрации данных или даже деактивации аккаунтов. Это все очень полезно для многих API, но для некоторых действий авторизация вовсе не требуется.

### API только для чтения (read-only)

Если ваш API полностью предназначен только для чтения (read-only), и передача данных не предполагается, тогда вы можете просто сделать его доступным без авторизации, и не беспокоиться об этом. Это вполне нормально.

Стоит позаботиться о том, что некоторые личности могут использовать против вашего API DDoS атакой (со злым умыслом засыпать API бесчисленным множеством запросов), но использование какой-нибудь формы авторизации может ограничить количество векторов атак. Для получения ответа от API пользователь должен быть валидным, а следовательно, если вредоносная активность была обнаружена, аккаунт пользователя должен быть заблокирован или деактивирован.

Такие меры не избавят полностью от DDoS атак, но зато API будет выполнять меньше работы, т.к. запрос будет завершен гораздо раньше, если пользователь будет определен как блокированный (invalid). Так что, если проблемы с DDoS атаками остаются (не зависимо от того, есть авторизация в API или нет), тогда решением может быть использование самосовершенствующегося фаервола или реализация других барьеров безопасности. Вообще говоря, будет не очень хорошо, если ваши сервера будет кто-нибудь спамить, по этому может стоит заранее перейти на проверку подлинности, чтобы избежать таких атак.

В любом случае вы можете сначала сделать свой API без авторизации, а затем по частям её реализовывать в дальнейшем.

### Внутреннее API

Если ваше API работает внутри приватной сети, или блокируется правилами фаервола, и вам не требуется наличие конкретных пользовательских данных, тогда, вероятно, авторизацию можно и не делать совсем.

Одна из проблем, которая касается безопасности всех сетей, это если сеть будет "пробита", тогда хакеры могут сделать много повреждений, т.к. если они имеют доступ ко всем вашим сетям, то вероятно осталось еще много нерешенных вопросов безопасности.

Помните об этом.

## Различные способы авторизации
### Способ №1: Basic Authentication

Первый способ, которым пользуется множество разработчиков, это HTTP Basic авторизация, который больше всего напоминает стандартный username/password подход, давно известный и полюбившийся, реализованный на уровне HTTP запроса и легко поддерживается браузерами.

Вот что в Wikipedia написано про него:

> HTTP Basic authentication (BA) реализует технически простой контроль доступа к web ресурсу, потому что не требует cookie, идентификатор сессии и страниц с формой авторизации. Зато, HTTP Basic авторизация использует статические, стандартные HTTP заголовки, что обеспечивает идентификацию без задержки.
> **Источник**: [Wikipedia](http://en.wikipedia.org/wiki/Basic_access_authentication)

**Плюсы**
- Простота в использовании
- Простота в понимании
- Работает в браузере и любых других HTTP клиентах

**Минусы**
- Очень не безопасно при использовании HTTP
- Довольно не безопасно при использовании HTTPS
- Пароли могут быть сохранены браузером, что является отличной приманкой для пользователей, только и ждущих заглотить эту наживку.

**Сохранение паролей браузером**

В браузере Chrome эти plain-text пароли даже не защищены мастер-ключем, вы реально оставляете ваших пользователей в открытом доступе для кражи, если вы используете HTTP Basic авторизацию.

Эллиот Кембер публично [описал эту проблему](http://blog.elliottkember.com/chromes-insane-password-security-strategy).
[The Guardian](http://www.theguardian.com/technology/2013/aug/07/google-chrome-password-security-flaw?INTCMP=SRCH).
[Sir Tim Berners-Lee](https://twitter.com/timberners_lee/status/364839351651274752).
[А Google воздержался](https://news.ycombinator.com/item?id=6166886).

**Другие проблемы plane-text**

Другая проблема безопасности Basic авторизации - это чертовски небезопасная работа через HTTP.

Например, заголовок, предоставляемый Wikipedia, будет размещен в HTTP запросе примерно вот так:
`Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==`

Если запрос ушел по проводам (например JS-based API запрос от пользователя, который сидел в кафе), тогда этот запрос мог быть очень просто перехвачен. Получив такой заголовок, как в примере, безумно просто получить username и password.

`1 $ php -a`
`2 php > echo base64_decode('QWxhZGRpbjpvcGVuIHNlc2FtZQ==');`
`3 Aladdin:open sesame`

Это не более и не менее безопасно, чем HTML форма входа, но это конечно не достаточно безопасно для любого API, принимающего данные. 

Использование SSL в значительной степени повышает безопасность, но так как пароль высылается в каждом HTTP запросе, то это остается потенциальной возможностью для его подбора - но это уже для тех, кто действительно хочет его получить.

HTTP Basic авторизация может действительно хорошо подойти для малозначимых, внутренних API, которые нуждаются только в базовой защите и должны быть реализованы быстро, но конечно совершенно не годится для всего, что связанно с деньгами, воздушным траффиком и ядерным оружием.

### Способ №2: Цифровая авторизация

Цифровой способ похож на Basic авторизацию, но разработан с упором на большую безопасность.

Вместо отправки паролей в виде plain-text, тут создается и отправляется MD5 хеш. По сравнению с Base64-based паролями, используемыми в Basic авторизации, MD5 является односторонним хешем, то есть вы не можете просто так взять хеш и рассчитать оригинальный пароль, не пробуя много различных комбинаций.

`HA1 = MD5(A1) = MD5(username:realm:password) HA2 = MD5(A2) = MD5(method:digestURI) response = MD5(HA1:nonce:HA2)`

nonce - это уникальный номер, который может содержать (но не обязательно), timestamp. Это может предотвратить повторные атаки, т.к. хеш уже не будет использоваться после этого времени.

**Плюсы**
- Пароль не передается как plane-text
- Использование nonce помогает избежать атаки [rainbow table](https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D0%B4%D1%83%D0%B6%D0%BD%D0%B0%D1%8F_%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0)
- Вообще говоря, более безопасна, чем Basic авторизация
- Проще в реализации, чем некоторые другие решения

**Минусы**
- Реализовать хорошо труднее, чем Basic авторизацию
- Просто реализовать плохо
- Остается незащищенной через HTTP
- Как и в Basic авторизации, пароли могут быть сохранены в браузере.
- Использует MD5

**MD5... 4... 3... 2... 1... Хакнуто** 

Сегодня MD5 воспринимается многими людьми как чрезвычайно подверженный взлому в большинстве сценариев. Цифровая авторизация так и не была улучшена с момента её создания в 1993 году, и хотя процесс расчета должен был предотвратить многие из этих проблем, плохая реализация цифровой авторизации открывает некоторые незаметные векторы атак, о которых вы узнаете только после их свершения.

Конечно, цифровая авторизация более безопасна, чем Basic. Она хороша в связке с SSL, безусловно, это хороший выбор для внутреннего API, если у вас конечно есть достаточно времени ее реализации, но требование пересылать постоянно username и password говорит о потенциальной уязвимости, если у хакера будет достаточно зашифрованных реквестов, доступных для обработки.

### Способ №3: OAuth 1.0a