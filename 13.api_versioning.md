# 13. Версионирование API
# 13.1 Введение
Когда вы напишите ваше замечательное новое API, вскоре может понадобиться в нем заменить старый или добавить новый функионал. К сожалению, нет никакого консенсуса какой подход для решения такой задачи будет лучшим.

Основной совет, который вы получите от экспертов звучит так: Постарайтесь ограничиться в изменениях API настолько, насколько это возможно. И это очень справедливое утверждение, но оно также немного похоже на отговорку. Независимо от того, насколько хорошо бы не было спланировано ваше API и ваши бизнес требования, скорее всего не получится следовать такому совету.

Особенно в мирее стартапов, где все менее структурировано. Все начинается с "Opportunities (возможностей)", которые превращаются в "Photo Opps (фото отчет)" и заканчивается все это так назаывемыми "Campaigns (кампаниями)". Вы можете смеяться, и говорить что это с вами никогда не случится, но всеже это случится. Когда вы будете меньше всего этого ожидать, к вам придут бизнес-требования и как скумбрия мокрым хвостом ударят по лицу. Когда это случится, версионирование API ваше единственное решение.

> Конечно, вы можете сказать, что выше API должно поддерживать обратную совместимость - но это не очень реально, когда ваш API должным образом используется на всей линейке продуктов. Чтобы продемонстрировать дальше, предположим, что у вас есть 30 приложений (и возможно горстка внешних компаний, использующих API), каждое из которых опирается на "клиентский" REST ресурс - тогда вы можете выбрать следующее:
>
> 1. Сохранять обратную совместимость (и потерять продаж на 1млн. долларов, потомучто вы не можете реализовать крутую функцию "X")
> 2. Внести изменения во все 30 приложений одновременно для обработки новых данных (но вам, вероятно, не хватит ресурсов чтобы сделать это вовремя и в срок)
> 3. Сделайте изменения, нарушив работу приложений, но получите продажи (конечно вы можете исправить оставшиеся приложения в будущем, правильно?)
>  **Источник**: [thereisnorightway.blogspot.com.tr](http://thereisnorightway.blogspot.com.tr/2011/02/versioning-and-types-in-resthttp-api.html)

## 13.2 Различные подходы в версионировании API
Как это было сделано в нескольких других главах, в этой главе будут изложены несколько различных подходов и перечислены их плюсы и минусы. В других главах как правило есть предложение, которое является "лучшим" решением, но в этой главе не так, и между ними есть компромиссы. Некоторые технически и являются RESTfull, но невероятно сложны в реализации и также сложны для использования вашими пользователями. Это означает, что при выборе подхода придется хорошенько пораскинуть мозгами.

На протяжении всей главы будут отсылки на различные популярные сервисы с публичным API и типами используемой версионности. Спасибо Тиму (Tim Wood) за составление обширного списка [“How are REST APIs versioned?”](http://www.lexicalscope.com/blog/2012/03/12/how-are-rest-apis-versioned/), на который буду часто ссылаться в этой главе.

### Подход №1: URL
Указывание номера версии в URL является очень распространенной практикой среди популярных публичных API.

По сути, вы просто добавляете `v1` или `1` в URL, потому указать следующиую версию не составит труда.

> `https://api.example.com/v1/places`

Такой подход довольно часто выбирается API разработчиками в своих проектах благодаря тому, что он имеет большую распространенность среди публичных API. Он достаточно прост и эффективен.

У Twitter имеется две версии: `/1/` и `/1.1/`, которые являлись рабочими на момент написания главы. Это дает разработчикам возможность обновить код, который ссылается на старые конечные точки (endpoints), так что они могут использовать новые. Большенство API назвали бы это как версию `2`, но там не было достаточно значительных изменений, возможно по этому они выбрали менее значимый номер.

Некоторые говорят, что URL версионность позволяет более удобно "копипастить" URL, чем другие подходы (многие из которых включают HTTP заголовки), и что их мол проще поддерживать. 

Это можеть быть верным в некоторых случаях, но вообще, слегка неправильно. Не RESTful API никогда не будут полностью удобны для "копипаста", потому что там всегда будут использоваться заголовки: `Cache-Control`, `Accept`, `Content-Type`, `Authorization`, и т.д. Попытка полностью уместить API запрос в URL выглядит очень глупо.

Аргумент "копипаста" является незначительным плюсом, по сравнению с тем какие у этого подхода есть потенциальные недостатки.

Первый аргумент, который можно услышать от людей, что технически это не RESTful. Идея заключается в том, что ресурс (resource) должен быть похож на постоянную ссылку. Эта ссылка никогда не должна изменяться, и она всегда должна быть там - так же, как пост в блоге. Если интернет пострен вокруг связывания всего вместе и эти связи (ссылки) все время меняются, то... вобщем все нарушится. Вы можете быть не слишком озабочены этим, особенно если API является внутреннм, но это может раздражать других.

Например, если вы храните URL конечной точки (endpoint) в вашей базе данных для дальнейшего использования, то выглядеть это может примерно так:

> `https://api.example.com/v1/places/213`

Однажды вы получаете email от `example.com`, в котором говорится, что  их **API v1** через три месяца больше не будет поддерживаться, и вам нужно по возможности начать пользоваться версией **API v2**.

Если вы обновляете свой код в соответствии с каким-либо обновленным форматом, в соответствии с новыми или переименованными полями, которые может содержать новая версия, то отлично, ваш новый код будет готов для работы с новой версией API и вы можете начать сохранять новый URL при добавлении записи в вашу базу данных. Это работает для новых записей, но вы не можете оставить старые записи, привязанные к старому URL от **API v1**.

Что же можно тут сделать? Одно из решений, это заменить строку старого URL и надеяться что новый URL будет правильный.

> `https://api.example.com/v2/places/213`

Это могло бы сработать, но факт в том, что в письме было замечание, в котором говорится что авто-инкрементный ID более не используется в их URL (они где-то прочитали, что это плохое решение) и решили использовать вместо него строковый идентификатор (*slug*):

> `https://api.example.com/v2/places/taksim-bunk-hostel`

Что теперь? Единственное решение в данном случае, это создать скрипт, который пройдется по каждой записи в вашей базе данных, дернет для этой записи ихний **API v1** и получит необходимую информацию (в надежде что этот строковый идентификатор *slug* доступен) и затем сформирует URL совместимый с **API v2** для сохранения.

Если вы это сделаете с несколькими миллионами записей, тогда вероятно быстро достигнете какого-нибудь лимита на запросы к API. Twitter, например, в некоторых случаях лимитирует доступ приложения к конечной точке (endpoint) на 15 минут за 15 запросов, так что в таком случае потребуется около двух недель для обновления 1 миллиона записей. 

Может это выглядит как крайний случай, но размещение версии API в URL порождает ряд всевозможных непонятных проблем, и вынуждает ваших разработчиков вручную формировать  URL ресурса с заменой строки, что выглядит довольно грубо. Питер Уильямс (Peter Williams) указал на это в статье под названием [“Versioning REST Web Services”](http://barelyenough.org/blog/2008/05/versioning-rest-web-services/) еще в 2008 году, но кажется, все его последовательно игнорируют.

Еще одним недостатком этого подхода является то, что указывать v1 и v2 к разным серверам может быть трудно, если вы не используете какой-ниубдь Apache Proxy или Nginx как прокси. В общем то, многие системы ожидается размещать на том же сервере иначе могут появиться накладные расходы. Так например, если v1 работает на PHP а v2 на Scala, вы можете столкнуться с некоторыми проблемами если все это запускать на одном и том же сервере.

Обратная сторона проблемы "трудоемкого размещения всего на одном сервере", это когда API разработчики используют единую кодовую базу обеспечивая версионность внутри самого web-приложения. Они просто создают роуты (routes) с префиксом `/v1/places`, затем, когда им нужно сделать версию `v2`, они копируют роуты, копируют контроллеры и кое-что донастраивают. Это *может быть* сделано, если вы также версионируете свои трансформеры (transformers - для поддержания структуры данных и типов данных), и уверены в том, что весь общий код (библиотеки, пакеты и т.д) будет поддерживаться и оставаться совместимым на всем протяжении. Это редкий случай, и люди добавляют `v1` в их URL адреса просто потому, что это единственное решение, которое они знают.

Вместо этого, давайте рассмотрим создание для каждой версии своей собственной кодовой базы. Это предполагает, что код полностью разделен, раздельно выполняется, на разных вирутальных хостах (vhosts) веб-сервера или может быть даже на разных серверах.

Если API версии очень похожи (тотже язык, тотже фреймворк и т.д.), тогда вы можете просто делить историю в GIT - будь то другая ветка в том же API репозитории или просто другая ветка. Некоторые люди используют модель [Git Flow](http://nvie.com/posts/a-successful-git-branching-model/) и добавляют номера версий, так один репозиторий может иметь следующие ветки:

 - 1.0/master
 - 1.0/develop
 - 2.0/master
 - 2.0/develop

Пока вы таким образом делите историю в GIT, вы можете вытащить из другого репозитория или ветки старую версию, и смержить изменения в новую версию. Это позволяет проще фиксить баги в нескольких версиях сразу, вместо копипаста между всеми вашими контроллерами при использовании единой кодовой базы.

#### Популярные API

 - Bitly 
 - Disqus
 - Dropbox
 - Bing (lol)
 - Etsy
 - Foursquare
 - Tumblr
 - Twitter
 - Yammer
 - YouTube

#### Плюсы

 - Невероятно прост для API разработчиков
 - Невероятно просто для API пользователей
 - Удобные для URLы для копипаста

#### Минусы

 - Технически не является RESTful
 - Сложен при размещении на отдельные сервера
 - Принуждает пользователей API прибегать к сложным и непонятным действиям для поддержания ссылок (links) в актуальном состоянии.

---

### Подход №2: Hostname


